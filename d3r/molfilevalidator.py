#! /usr/bin/env python

import sys
import os
import argparse
import glob
import logging
import tarfile
import shutil
import tempfile
import pickle

try:
    OPENEYE_MOD_LOADED = False
    from openeye import oechem
    try:
        if oechem.OEChemIsLicensed():
            OPENEYE_MOD_LOADED = True
        else:
            sys.stderr.write('WARNING: No valid license found for openeye ' +
                             'Please verify OE_LICENSE environment variable'
                             'is set to valid license file\n')
    except AttributeError as ae:
        sys.stderr.write('WARNING Unable to check if openey is licensed' +
                         str(ae))
except ImportError as e:
    sys.stderr.write('WARNING: Unable to import oechem: ' +
                     str(e) + ' validation will NOT work\n')
    pass


import d3r
from d3r.celpp import util
from d3r.celpp.task import D3RParameters


# create logger
logger = logging.getLogger('d3r.molfilevalidator')
DEFAULT_LOG_LEVEL = 'ERROR'
p = D3RParameters()
p.loglevel = DEFAULT_LOG_LEVEL
util.setup_logging(p)


# delimiter used to extract ligand name from molecule file
LIG_NAME_DELIM = '-'

# suffix for .mol aka molecule files
MOL_SUFFIX = '.mol'

# supported modes which are set by user
# via first argument to script
VALIDATE_MODE='validate'
GENMOLECULEDB_MODE='genmoleculedb'

# optional command line parameters
USER_SUBMISSION = 'usersubmission'
OUTFILE = 'outputfile'
MOLDB = 'moleculedb'


def _parse_arguments(desc, args):
    """Parses command line arguments using argparse.
    """
    parsed_arguments = D3RParameters()

    help_formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(description=desc,
                                     formatter_class=help_formatter)
    parser.add_argument("mode", choices=[VALIDATE_MODE, GENMOLECULEDB_MODE],
                        help='Sets what mode script will run in. ' +
                             VALIDATE_MODE + ' mode checks a usersubmission ' +
                             'set by --' + USER_SUBMISSION + ' flag and ' +
                        GENMOLECULEDB_MODE + ' mode generates the molecule ' +
                        ' database writing it to --' + OUTFILE)
    parser.add_argument('--moldir', help='Directory containing mol files used to '
                                         'generate database from')
    # parser.add_argument('--molcsv', help='CSV file sent to participants')
    # parser.add_argument('--molcsvligandcol', help='0 offset column containing ligand ids')
    # parser.add_argument('--molcsvsmilescol', help='0 offset column containing smile strings')
    parser.add_argument('--skipligand', help='comma delimited list of ligands to skip')
    parser.add_argument('--' + USER_SUBMISSION,
                        help='tar.gz file containing .mol files to validate')
    parser.add_argument('--' + OUTFILE,
                        help='Destination file to write molecule database')
    parser.add_argument('--' + MOLDB,
                        help='Molecule database generated by --' +
                             GENMOLECULEDB_MODE + ' mode')
    parser.add_argument("--log", dest="loglevel",
                        choices=['DEBUG', 'INFO', DEFAULT_LOG_LEVEL,
                                 'ERROR', 'CRITICAL'],
                        help="Set the logging level (default " +
                             DEFAULT_LOG_LEVEL + ")", default=DEFAULT_LOG_LEVEL)
    parser.add_argument('--version', action='version',
                        version=('%(prog)s ' + d3r.__version__))
    return parser.parse_args(args, namespace=parsed_arguments)


class D3RAtom(object):
    """Represents an Atom"""
    def __init__(self):
        """Constructor"""
        self._ishydrogen = False
        self._atomicnumber = 0
        self._name = ''

    def is_hydrogen(self):
        """Gets boolean denoting if atom is a hydrogen
        :returns bool: True if its a hydrogen otherwise False
        """
        return self._ishydrogen

    def set_is_hydrogen(self, val):
        """Sets value for IsHydrogen
        """
        self._ishydrogen = val

    def get_atomic_number(self):
        """Gets atomic number"""
        return self._atomicnumber

    def set_atomic_number(self, val):
        """SEts atomic number"""
        self._atomicnumber = val

    def get_atomic_name(self):
        """Gets atomic name"""
        return self._name

    def set_atomic_name(self, val):
        """Sets atomic name"""
        self._name = val


class D3RMolecule(object):
    """Represents a Molecule"""
    def __init__(self):
        self._atoms = None

    def set_atoms(self, atoms):
        """Sets list of atoms
        """
        self._atoms = atoms

    def get_atoms(self):
        """Gets list of atoms
        """
        return self._atoms


class D3RMoleculeFromOpeneyeFactory(object):
    def __init__(self):
        """Constructor"""

    def get_d3rmolecule(self, source):
        """Gets D3RMolecule from `source`
        """
        openeye_mol = self._get_molecule_from_openeye(source)
        d3ratoms = []
        for atom in openeye_mol.GetAtoms():
            d3ratom = D3RAtom()
            d3ratom.set_atomic_name(atom.GetName())
            d3ratom.set_atomic_number(atom.GetAtomicNum())
            d3ratom.set_is_hydrogen(atom.IsHydrogen())
            d3ratoms.append(d3ratom)

        d3rmol = D3RMolecule()
        d3rmol.set_atoms(d3ratoms)
        return d3rmol

    def _get_molecule_from_openeye(self, source):
        """Uses openeye oechem to read in smile_str and
        create oechem.OEMol() object
        """
        istream = self._get_oechem_istream(source)
        openeye_mol = oechem.OEMol()
        try:
            val = oechem.OEReadMolecule(istream, openeye_mol)
            if val is False:
                raise ValueError('OEReadMolecule returned False '
                                 'when trying to read mol file')
        finally:
            istream.close()
        return openeye_mol


class D3RMoleculeFromMolFileViaOpeneyeFactory(D3RMoleculeFromOpeneyeFactory):
    """Creates D3RMolecule objects using """
    def __init__(self):
        """Constructor"""
        super(D3RMoleculeFromOpeneyeFactory, self).__init__()

    def _get_oechem_istream(self, source):
        istream = oechem.oemolistream()
        istream.open(source)
        return istream


class D3RMoleculeFromSmileViaOpeneyeFactory(D3RMoleculeFromOpeneyeFactory):
    """Creates D3RMolecule objects using """
    def __init__(self):
        """Constructor"""
        super(D3RMoleculeFromOpeneyeFactory, self).__init__()

    def _get_oechem_istream(self, source):
        istream = oechem.oemolistream()
        istream.SetFormat(oechem.OEFormat_SMI)
        istream.openstring(source)
        return istream


def get_molecule_weight_and_summary(themolecule):
    """Parses Molecule object `rdmol` to generate
       summary information about the molecule
    :param themolecule: `oechm.OEMol()` already loaded
    :return: tuple (# of non hydrogen atoms, non-hydrogen atomic weight,
                    dictionary where key is atomic # and values are a count
                    of atoms of that type)
    """
    atom_dic = {}
    heavy_atom = 0
    molecular_weight = 0
    if themolecule is None:
        logger.error('Molecule passed in is None')
        return -1, -1, {}

    if themolecule.get_atoms() is None:
        logger.error('Molecule has None for atoms')
        return heavy_atom, molecular_weight, atom_dic

    for atom in themolecule.get_atoms():
        if not atom.is_hydrogen():
            heavy_atom +=1
            atomical_number = atom.get_atomic_number()
            molecular_weight += atomical_number
            if atomical_number not in atom_dic:
                atom_dic[atomical_number] = 1
            else:
                atom_dic[atomical_number] += 1
        logger.debug('Atom (' + str(atom.get_atomic_name()) +
                     ') atomic weight (' +
                     str(molecular_weight) + ') atom dictionary ' +
                     str(atom_dic))
    return heavy_atom, molecular_weight, atom_dic


class CompareMolecules(object):
    """Compares 2 D3RMolecule objects
    """
    def __init__(self, moleculedb):
        """Constructor"""
        self._moleculedb = moleculedb

    def compare_molecules(self, molfile, vreport, ligand_name,
                          user_molecule):
        """Compares the `user_molecule` assumed to be right answer with
        data in the moleculedb set in Constructor.
        :returns: string with error or None upon success
        """
        if ligand_name not in self._moleculedb:
            vreport.add_ligand_error(molfile, ligand_name,
                                     'ligand not in molecule database')
            return False

        (h_atom, m_weight,
         atom_dic) = get_molecule_weight_and_summary(user_molecule)

        if h_atom == self._moleculedb[ligand_name][0]:
            if m_weight == self._moleculedb[ligand_name][1]:
                return True

        vreport.add_molecule_error(molfile, ligand_name,
                                   (h_atom, m_weight, atom_dic),
                                   self._moleculedb[ligand_name],
                                   'Number of heavy atoms and or molecular weight '
                                   'did not match ')
        return False


class ValidationReport(object):
    MOLFILE = 'molfile'
    LIGAND = 'ligand'
    MESSAGE = 'message'
    USERMOL = 'usermol'
    EXPECTEDMOL = 'expectedmol'

    def __init__(self):
        """Constructor"""
        self._ligand_errors = []
        self._mol_errors = []

    def get_ligand_errors(self):
        """Gets list of ligand errors in list of dictionaries with format:
          [{ValidationReport.MOLFILE: molfile,
           ValidationReport.LIGAND: ligand_name,
           ValidationReport.MESSAGE: message}]
        """
        return self._ligand_errors

    def get_molecule_errors(self):
        """Gets list of ligand errors in list of dictionaries with format:
          [{ValidationReport.MOLFILE: molfile,
           ValidationReport.LIGAND: ligand_name,
           ValidationReport.USERMOL: usermoltuple,
           ValidationReport.EXPECTEDMOL: dbmoltuple,
           ValidationReport.MESSAGE: message})]

           usermoltuple and dbmoltuple are from output from
           `get_molecule_weight_and_summary()`
        """
        return self._mol_errors

    def add_ligand_error(self, molfile, ligand_name, message):
        """Adds error message with ligand name"""
        self._ligand_errors.append({ValidationReport.MOLFILE: molfile,
                                    ValidationReport.LIGAND: ligand_name,
                                    ValidationReport.MESSAGE: message})

    def add_molecule_error(self, molfile, ligand_name, usermoltuple,
                           dbmoltuple, message):
        self._mol_errors.append({ValidationReport.MOLFILE: molfile,
                                 ValidationReport.LIGAND: ligand_name,
                                 ValidationReport.USERMOL: usermoltuple,
                                 ValidationReport.EXPECTEDMOL: dbmoltuple,
                                 ValidationReport.MESSAGE: message})

    def get_as_string(self):
        """Iterates across ligand and molecule errors
        outputting a human readable report of the problems
        """
        res = ''
        if len(self._ligand_errors) > 0:
            res += '\nLigand Errors\n------------\n\n'

        for entry in self._ligand_errors:
            res += ('In file: ' +\
                    os.path.basename(str(entry[ValidationReport.MOLFILE])))
            res += (' ligand: ' + str(entry[ValidationReport.LIGAND]) + '\n\t' +
                    str(entry[ValidationReport.MESSAGE]) + '\n\n')

        if len(self._mol_errors) > 0:
            res += '\nMolecule Errors\n------------\n\n'

        for entry in self._mol_errors:
            logger.debug('For: ' + str(entry[ValidationReport.MOLFILE]))
            res += ('In file: ' +\
                    os.path.basename(str(entry[ValidationReport.MOLFILE])))

            if entry[ValidationReport.EXPECTEDMOL] is None or \
               entry[ValidationReport.USERMOL] is None:
                res += (' ligand: ' + str(entry[ValidationReport.LIGAND]) +
                        '\n\t' +
                        str(entry[ValidationReport.MESSAGE]) + '\n\n')
            else:

                exp_nonh_atoms = str(entry[ValidationReport.EXPECTEDMOL][0])
                usr_nonh_atoms = str(entry[ValidationReport.USERMOL][0])
                exp_m_weight = str(entry[ValidationReport.EXPECTEDMOL][1])
                usr_m_weight = str(entry[ValidationReport.USERMOL][1])

                exp_atom_map = str(entry[ValidationReport.EXPECTEDMOL][2])
                usr_atom_map = str(entry[ValidationReport.USERMOL][2])

                res += (' ligand: ' + str(entry[ValidationReport.LIGAND]) + ' ' +
                        str(entry[ValidationReport.MESSAGE]) + '\n')

                if exp_nonh_atoms != usr_nonh_atoms:
                    res += ('\tExpected ' + exp_nonh_atoms +
                            ' non hydrogen atoms, but got ' +
                            usr_nonh_atoms + '\n')
                if exp_m_weight != usr_m_weight:
                    res += ('\tExpected ' + exp_m_weight +
                            ' for non hydrogen atomic weight, but got ' +
                            usr_m_weight + '\n')
                res += ('\tExpected atom map { atomic #: # atoms,...} ' +
                        exp_atom_map + ', but got ' + usr_atom_map + '\n\n')

        return res


def _get_ligand_name_from_file_name(file_name):
    """Extracts ligand name from file name. It is assume
    the file name has format of XXXX-<LIGAND NAME>-X.mol
    """
    if file_name is None:
        raise ValueError('file_name cannot be None')

    base_fname = os.path.basename(file_name)
    hyphen_split = base_fname.split(LIG_NAME_DELIM)
    if len(hyphen_split) < 2:
        raise ValueError('Error parsing ligand name from file name: ' +
                         base_fname)
    return hyphen_split[1]


def _generate_molecule_database(theargs, molfactory):
    search_path = os.path.join(theargs.moldir, '*' + MOL_SUFFIX)
    all_mol_files = glob.glob(search_path)
    ligand_dic = {}
    for mol_file in all_mol_files:
        logger.info('Reading file: ' + mol_file)
        ligand_name = _get_ligand_name_from_file_name(mol_file)
        logger.info('Ligand: ' + ligand_name)
        themol = molfactory.get_d3rmolecule(mol_file)
        if not ligand_name in ligand_dic:
            ligand_dic[ligand_name] = get_molecule_weight_and_summary(themol)

    logger.debug('Writing output to: ' + theargs.outputfile)
    p_f = open(theargs.outputfile, "w")
    pickle.dump(ligand_dic, p_f)
    p_f.close()
    return 0


def _molfile_from_tarfile_generator(thefile, tmpdir=None):
    """Generator method that takes a tarfile and
       returns molfiles written to a temporary directory
    """
    temp_dir = tempfile.mkdtemp(dir=tmpdir)
    tf = None
    try:
        tf = tarfile.open(thefile, 'r:gz')
        for entry in tf.getmembers():
            if entry.name.endswith(MOL_SUFFIX) and entry.isfile():
                fname = os.path.basename(entry.name)
                dest_molfile = os.path.join(temp_dir, fname)
                with open(dest_molfile, 'w') as f:
                    shutil.copyfileobj(tf.extractfile(entry), f)
                yield dest_molfile
    finally:
        shutil.rmtree(temp_dir)
        if tf is not None:
            tf.close()


def _get_molecule_database(theargs):
    mol_db_file = open(theargs.moleculedb, 'r')
    mole_db = pickle.load(mol_db_file)
    mol_db_file.close()
    return mole_db


def _validate_molfiles_in_tarball(theargs, molfactory, moleculedb):
    """Generates molecule validation report
    """
    ligand_skip_list = theargs.skipligand.split(',')
    comparemols = CompareMolecules(moleculedb)
    report = ValidationReport()
    for molfile in _molfile_from_tarfile_generator(theargs.usersubmission):
        try:
           ligand_name = _get_ligand_name_from_file_name(molfile)
        except ValueError as e:
            report.add_ligand_error(molfile, ligand_name, str(e))
            continue
        if ligand_name in ligand_skip_list:
            logger.debug(ligand_name + ' in skip list. Skipping...')
            continue
        if ligand_name not in moleculedb:
            report.add_ligand_error(molfile, ligand_name,
                                    'ligand not in molecule database')
            continue
        try:
            d3rmol = molfactory.get_d3rmolecule(molfile)
        except Exception as e:
            report.add_molecule_error(molfile, ligand_name, None, None,
                                      'Unable to parse file: ' + str(e))
            continue
        comparemols.compare_molecules(molfile, report, ligand_name, d3rmol)
    return report


def _run_validation(theargs, molfactory):
    moleculedb = _get_molecule_database(theargs)
    report = _validate_molfiles_in_tarball(theargs, molfactory, moleculedb)

    report_str = report.get_as_string()
    if report_str == '':
        return 0
    sys.stdout.write(report_str)
    return 1

"""ORIGINAL SCRIPT

def validation_mol (template_pickle, mol_file_path, result_log, log_update = True, ignore_ligand = ["FXR_33"]):
    template_p = open(template_pickle,"r")
    template_dic = pickle.load(template_p)
    template_p.close()
    log_lines = []
    all_mol_files = glob.glob("%s/*.mol"%mol_file_path)
    print "AAAAAAAAAAAAAAAAA", all_mol_files
    passed = True
    for mol_file in all_mol_files:
        try:
            #for stage 2 the file don't have the pose number so need to split furthert to get the ligand name
            ligand_name = os.path.splitext(os.path.basename(mol_file))[0].split("-")[1]
            if ligand_name in ignore_ligand:
                continue
        except:
            log_lines.append("Fatal Error: The ligand name of the mol file:%s cannot be extracted, need to check the naming\n"%(ligand_name))
            passed = False
        if ligand_name not in template_dic:
            log_lines.append("Fatal Error: This ligand: %s corresponding to this mol file: %s could not be found in the template, need to check how the mol file be named...\n"%(ligand_name, os.path.basename(mol_file)))
            passed = False
        else:
            try:
                print "CCCCCCCCCCCCCCCCCC", mol_file
                #raw_input()
                istream = oechem.oemolistream()
                istream.open(mol_file)
                rd_mol = oechem.OEMol()
                oechem.OEReadMolecule(istream, rd_mol)
                print "IIIIIIIIIIIIIII", rd_mol.GetAtoms()
                istream.close()
            except:
                log_lines.append("Fatal Error: This mol file %s cannot be parse as OpenEye OEMol object, need to check the format...\n"%(os.path.basename(mol_file)))

                rd_mol = False
                passed = False
            if rd_mol:
                heavy_atoms, molecular_weight, atom_dic = get_molecule_weight_and_summary(rd_mol)
            else:
                log_lines.append("Fatal Error: This mol file %s cannot be parse as OpenEye OEMol object, need to check the format...\n"%(os.path.basename(mol_file)))
                passed = False
                continue
            if (heavy_atoms, molecular_weight) == (template_dic[ligand_name][0], template_dic[ligand_name][1]):
                log_lines.append("This ligand :%s in this file: %s passed the validation\n"%(ligand_name, os.path.basename(mol_file)))
            else:
                log_lines.append("Fatal Error: This ligand: %s in this file: %s failed the validation\n"%(ligand_name, os.path.basename(mol_file)))
                log_lines.append("      This ligand has %s heavy atoms and the mol weight is %s\n"%(heavy_atoms, molecular_weight))
                log_lines.append("      This ligand has atom dictionary as %s, note: the atom dictionary format is {atomic number: number of atoms}\n"%(atom_dic))
                log_lines.append("      The template has %s heavy atoms and the mol weight is %s\n"%(template_dic[ligand_name][0], template_dic[ligand_name][1]))
                log_lines.append("      The template has atom dictionary as %s, note: the atom dictionary format is {atomic number: number of atoms}\n"%(template_dic[ligand_name][2]))
                passed = False
    if not passed:
        log_lines.append("This submittion failed the validation because of the Fatal Errors...\n")
        out_f = open(result_log, "w")
        out_f.writelines(log_lines)
        out_f.close()
        return False
    else:
        log_lines.append("This submittion passed the mol file validation\n")
        out_f = open(result_log, "w")
        out_f.writelines(log_lines)
        out_f.close()
        return True

#main code
logger = logging.getLogger()
logging.basicConfig( format  = '%(asctime)s: %(message)s', datefmt = '%m/%d/%y %I:%M:%S', filename = 'final.log', filemode = 'w', level   = logging.INFO )
#logging.basicConfig( filename = 'final.log', filemode = 'w', level   = logging.INFO )

template_pickle = "mw_na_template_openeye.pickle"
main_folder_path = os.getcwd()
validation = validation_mol(template_pickle, main_folder_path, "final.log")
print "Passed the validation:%s"%validation
if not validation:
    commands.getoutput('touch "failed"')

"""


def main(args):
    """Main entry into genmoleculedb
    :param args: should be set to sys.argv which is a list of arguments
                 starting with script name as the first argument
    """
    desc = """
              Version {version}

              Validates a set of .mol files found in input directory
              (http://www.drugdesigndata.org)

              """.format(version=d3r.__version__)

    theargs = _parse_arguments(desc, args[1:])
    theargs.program = args[0]
    theargs.version = d3r.__version__

    util.setup_logging(theargs)

    try:
        molfactory = D3RMoleculeFromMolFileViaOpeneyeFactory()

        if theargs.mode == GENMOLECULEDB_MODE:
            logger.info('Running in ' + GENMOLECULEDB_MODE +
                        ' database generation mode')
            return _generate_molecule_database(theargs, molfactory)
        if theargs.mode == VALIDATE_MODE:
            logger.info('Running in ' + VALIDATE_MODE + ' validation mode')
            return _run_validation(theargs, molfactory)
        raise ValueError('Unsupported mode: ' + theargs.mode)
    except Exception:
        logger.exception("Error caught exception")
        return 2


if __name__ == '__main__':  # pragma: no cover
    sys.exit(main(sys.argv))
